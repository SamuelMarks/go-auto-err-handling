package filter

import (
	"go/token"
	"go/types"
	"os"
	"path/filepath"
	"testing"
)

// TestMatchesFile verifies file exclusion logic using glob patterns.
func TestMatchesFile(t *testing.T) {
	fset := token.NewFileSet()

	// Create dummy files in the FileSet
	// Note: For globs, path existence on disk isn't strictly required by Match,
	// but file names must match pattern logic.
	f1 := fset.AddFile("/abs/path/to/main.go", -1, 100)
	f2 := fset.AddFile("/abs/path/to/main_test.go", -1, 100)
	f3 := fset.AddFile("relative/vendor/lib.go", -1, 100)

	tests := []struct {
		name      string
		globs     []string
		pos       token.Pos
		wantMatch bool
	}{
		{
			name:      "NoGlobs",
			globs:     nil,
			pos:       f1.Pos(1),
			wantMatch: false,
		},
		{
			name:      "MatchBaseName",
			globs:     []string{"*_test.go"},
			pos:       f2.Pos(1),
			wantMatch: true,
		},
		{
			name:      "NoMatchBaseName",
			globs:     []string{"*_test.go"},
			pos:       f1.Pos(1),
			wantMatch: false,
		},
		{
			name:      "MatchDirectory",
			globs:     []string{"*/vendor/*"},
			pos:       f3.Pos(1),
			wantMatch: true,
		},
		{
			name:      "InvalidPosition",
			globs:     []string{"*"},
			pos:       token.NoPos,
			wantMatch: false,
		},
		{
			name:      "NilFileSet",
			globs:     []string{"*"},
			pos:       f1.Pos(1),
			wantMatch: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			f := New(tt.globs, nil)

			var fs *token.FileSet
			if tt.name != "NilFileSet" {
				fs = fset
			}

			if got := f.MatchesFile(fs, tt.pos); got != tt.wantMatch {
				t.Errorf("MatchesFile() = %v, want %v", got, tt.wantMatch)
			}
		})
	}
}

// TestMatchesFile_Generated checks if files with the "Code generated" header are automatically skipped.
func TestMatchesFile_Generated(t *testing.T) {
	tmpDir := t.TempDir()
	fset := token.NewFileSet()

	// Helper to create file content and register in FileSet
	createFile := func(name, content string) token.Pos {
		path := filepath.Join(tmpDir, name)
		if err := os.WriteFile(path, []byte(content), 0644); err != nil {
			t.Fatalf("failed to write %s: %v", name, err)
		}
		tf := fset.AddFile(path, -1, len(content))
		return tf.Pos(1)
	}

	t.Run("StandardGenerated", func(t *testing.T) {
		pos := createFile("gen.go", "// Code generated by protoc-gen-go. DO NOT EDIT.\npackage p")
		f := New(nil, nil)
		if !f.MatchesFile(fset, pos) {
			t.Error("Expected match for standard generated header")
		}
	})

	t.Run("GeneratedWithTool", func(t *testing.T) {
		pos := createFile("mock.go", "// Code generated by MockGen. DO NOT EDIT.\npackage p")
		f := New(nil, nil)
		if !f.MatchesFile(fset, pos) {
			t.Error("Expected match for tool generated header")
		}
	})

	t.Run("NormalFile", func(t *testing.T) {
		pos := createFile("normal.go", "// This code was written by a human.\npackage p")
		f := New(nil, nil)
		if f.MatchesFile(fset, pos) {
			t.Error("Did not expect match for normal file")
		}
	})

	t.Run("GeneratedCommentLate", func(t *testing.T) {
		// Header must appear early (within 20 lines) to match convention
		// and optimize performance.
		lines := ""
		for i := 0; i < 25; i++ {
			lines += "// line\n"
		}
		lines += "// Code generated by tool. DO NOT EDIT.\n"
		pos := createFile("late.go", lines)
		f := New(nil, nil)
		if f.MatchesFile(fset, pos) {
			t.Error("Expected no match for late header outside scan window")
		}
	})

	t.Run("EditAllowed", func(t *testing.T) {
		// Header matching prefix but not strict suffix
		pos := createFile("edit.go", "// Code generated by tool. EDIT AT YOUR OWN RISK.\n")
		f := New(nil, nil)
		if f.MatchesFile(fset, pos) {
			t.Error("Expected no match for non-standard header")
		}
	})
}

// TestMatchesSymbol verifies symbol exclusion logic using fully qualified names.
func TestMatchesSymbol(t *testing.T) {
	pkgFmt := types.NewPackage("fmt", "fmt")
	pkgMy := types.NewPackage("example.com/my/pkg", "pkg")

	fnPrintln := types.NewFunc(token.NoPos, pkgFmt, "Println", nil)
	fnRun := types.NewFunc(token.NoPos, pkgMy, "Run", nil)
	fnInternal := types.NewFunc(token.NoPos, nil, "panic", nil)

	tests := []struct {
		name      string
		globs     []string
		fn        *types.Func
		wantMatch bool
	}{
		{
			name:      "NoGlobs",
			globs:     nil,
			fn:        fnPrintln,
			wantMatch: false,
		},
		{
			name:      "ExactMatch",
			globs:     []string{"fmt.Println"},
			fn:        fnPrintln,
			wantMatch: true,
		},
		{
			name:      "PackageWildcard",
			globs:     []string{"fmt.*"},
			fn:        fnPrintln,
			wantMatch: true,
		},
		{
			name:      "DomainWildcard",
			globs:     []string{"example.com/my/pkg.*"},
			fn:        fnRun,
			wantMatch: true,
		},
		{
			name:      "RecursiveWildcardNotSupportedByMatch",
			globs:     []string{"pkg.Run"},
			fn:        fnRun,
			wantMatch: false,
		},
		{
			name:      "SuffixMatch",
			globs:     []string{"*/*/*.Run"},
			fn:        fnRun,
			wantMatch: true,
		},
		{
			name:      "BuiltinMatch",
			globs:     []string{"panic"},
			fn:        fnInternal,
			wantMatch: true,
		},
		{
			name:      "NilFunc",
			globs:     []string{"*"},
			fn:        nil,
			wantMatch: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			f := New(nil, tt.globs)
			if got := f.MatchesSymbol(tt.fn); got != tt.wantMatch {
				t.Errorf("MatchesSymbol() = %v, want %v", got, tt.wantMatch)
			}
		})
	}
}
