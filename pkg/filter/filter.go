package filter

import (
	"bufio"
	"errors"
	"fmt"
	"go/token"
	"go/types"
	"os"
	"path/filepath"
	"regexp"
)

// generatedCodeRegexp matches the standard header line for generated files.
// Go guideline: "// Code generated by ... DO NOT EDIT."
var generatedCodeRegexp = regexp.MustCompile(`^// Code generated .* DO NOT EDIT\.$`)

// Filter determines whether specific files or symbols should be excluded from analysis.
// It uses glob patterns for file paths and symbol names, and inspects file headers for generated code markers.
type Filter struct {
	fileGlobs   []string
	symbolGlobs []string
}

// New creates a new Filter with the provided glob patterns.
//
// fileGlobs: A list of patterns to match against file paths (e.g., "*_test.go", "vendor/*").
// symbolGlobs: A list of patterns to match against fully qualified symbol names (e.g., "fmt.*", "github.com/pkg/errors.Wrap").
func New(fileGlobs, symbolGlobs []string) *Filter {
	return &Filter{
		fileGlobs:   fileGlobs,
		symbolGlobs: symbolGlobs,
	}
}

// MatchesFile checks if the file corresponding to the provided token.Pos is excluded.
// It excludes files if:
// 1. The filename matches a configured exclude glob.
// 2. The file content contains a standard "Code generated ... DO NOT EDIT." header in the first 20 lines.
//
// fset: The file set containing the position.
// pos: The position within the file to check.
func (f *Filter) MatchesFile(fset *token.FileSet, pos token.Pos) (bool, error) {
	if fset == nil || !pos.IsValid() {
		return false, nil
	}

	tf := fset.File(pos)
	if tf == nil {
		return false, nil
	}

	path := tf.Name()

	// 1. Check Glob Patterns
	if f.matchesGlob(path) {
		return true, nil
	}

	// 2. Check Generated Header
	// We check for error from read to bubble it up, ensuring robust failure handling if permissions deny.
	isGen, err := isGeneratedFile(path)
	if err != nil {
		return false, err
	}
	if isGen {
		return true, nil
	}

	return false, nil
}

// matchesGlob checks if the path matches the configured file globs.
func (f *Filter) matchesGlob(path string) bool {
	for _, pattern := range f.fileGlobs {
		// Check against full path
		matched, err := filepath.Match(pattern, path)
		if err == nil && matched {
			return true
		}

		// Check against base name
		base := filepath.Base(path)
		matchedBase, errBase := filepath.Match(pattern, base)
		if errBase == nil && matchedBase {
			return true
		}
	}
	return false
}

// isGeneratedFile opens the file and scans the first 20 lines for the standard generated code header.
// Returns true if found, false otherwise.
func isGeneratedFile(path string) (b bool, err error) {
	file, err := os.Open(path)
	if err != nil {
		// If we can't open it (e.g. doesn't exist or no permission), we return error.
		// Caller decides if this is a skip or a failure.
		return false, err
	}
	defer func() {
		err = errors.Join(err, file.Close())
	}()

	scanner := bufio.NewScanner(file)
	// Limit check to header (standard convention says it appears near top)
	const maxLines = 20
	count := 0
	for scanner.Scan() && count < maxLines {
		line := scanner.Text()
		if generatedCodeRegexp.MatchString(line) {
			return true, nil
		}
		count++
	}
	if err := scanner.Err(); err != nil {
		return false, err
	}
	return false, nil
}

// MatchesSymbol checks if the provided function symbol is excluded.
// It constructs the fully qualified name (<package-path>.<function-name>) and checks against symbol globs.
//
// fn: The function object to check.
func (f *Filter) MatchesSymbol(fn *types.Func) bool {
	if fn == nil {
		return false
	}

	pkgName := ""
	if fn.Pkg() != nil {
		pkgName = fn.Pkg().Path()
	}

	fullName := fn.Name()
	if pkgName != "" {
		fullName = fmt.Sprintf("%s.%s", pkgName, fn.Name())
	}

	for _, pattern := range f.symbolGlobs {
		matched, err := filepath.Match(pattern, fullName)
		if err == nil && matched {
			return true
		}
	}

	return false
}
